---
# ðŸ³ Docker Compose â€“ Master Guide (DevOps Notes)

## Introduction

Docker Compose is a powerful tool for **defining and running multi-container Docker applications**.
Instead of managing multiple `docker run` commands, Docker Compose lets you manage your entire stack using a **single YAML file**.
---

## â“ What is Docker Compose?

Docker Compose allows you to:

- Define multiple services
- Configure networking & volumes
- Start and stop everything using **one command**

```bash
docker-compose up -d
```

---

## âœ… Why Use Docker Compose?

- **Simplifies multi-container apps**
- **Improves development workflow**
- **Automatic service networking**
- **Easy environment recreation**
- **Same config for dev, test, staging**

---

## ðŸ§© Components of a Compose File

| Component  | Description                    |
| ---------- | ------------------------------ |
| `version`  | Compose file format version    |
| `services` | Containers in your application |
| `networks` | Custom networking              |
| `volumes`  | Persistent storage             |
| `configs`  | External configuration files   |

---

## âš™ï¸ Installing Docker Compose (Linux)

```bash
sudo curl -L "https://github.com/docker/compose/releases/download/1.29.1/docker-compose-$(uname -s)-$(uname -m)" \
-o /usr/local/bin/docker-compose

sudo chmod +x /usr/local/bin/docker-compose
docker-compose version
```

> ðŸ’¡ Docker Desktop already includes Compose.

---

## ðŸ§  Basic Docker Compose Commands

```bash
docker-compose up -d        # start services
docker-compose build        # build images
docker-compose down         # stop & remove containers
docker-compose ps           # list containers
docker-compose logs         # view logs
docker-compose stop         # stop containers
docker-compose config       # validate config
docker-compose images       # list images
docker-compose pause        # pause services
docker-compose unpause      # unpause services
```

---

## ðŸ“„ Basic Compose File Structure

```yaml
version: "3"
services:
  webapp1:
    container_name: webapp1
    build: ./app1
    ports:
      - "8081:80"

  webapp2:
    container_name: webapp2
    build: ./app2
    ports:
      - "8082:80"
```

---

## ðŸš€ Real-Time Example: Multiple Services

### Clone Repo

```bash
git clone https://github.com/devops0014/compose.git
cd compose/paytm
```

Folders:

```
bus-tickets/
movie-tickets/
train-tickets/
```

---

### Compose File (3 Services)

```yaml
version: "3"
services:
  movie:
    container_name: movie-container
    build: ./movie-tickets
    ports:
      - "8081:80"

  bus:
    container_name: bus-container
    build: ./bus-tickets
    ports:
      - "8082:80"

  train:
    container_name: train-container
    build: ./train-tickets
    ports:
      - "8083:80"
```

---

### Build & Run

```bash
docker-compose build
docker-compose up -d
docker-compose ps
```

---

## ðŸ“¦ Volumes in Docker Compose

### Why volumes?

- Persist data
- Share data between containers
- Avoid data loss on container recreation

---

### Compose with Volumes (Read-Only)

```yaml
version: "3"
services:
  movie:
    container_name: movie-container
    build: ./movie-tickets
    ports:
      - "8081:80"
    volumes:
      - movie_volume:/usr/share/nginx/html:ro

  bus:
    container_name: bus-container
    build: ./bus-tickets
    ports:
      - "8082:80"
    volumes:
      - bus_volume:/usr/share/nginx/html:ro

  train:
    container_name: train-container
    build: ./train-tickets
    ports:
      - "8083:80"
    volumes:
      - train_volume:/usr/share/nginx/html:ro

volumes:
  movie_volume:
  bus_volume:
  train_volume:
```

---

### Verify

```bash
docker-compose ps
docker volume ls
```

Modify volume content:

```bash
vim /var/lib/docker/volumes/paytm_movie_volume/_data/index.html
```

âœ” Changes reflect instantly in browser

---

## ðŸŒ Networks in Docker Compose

### Default Behavior

- Compose automatically creates **one network**
- All services can communicate

---

### Custom Networks (Isolation)

```yaml
version: "3"
services:
  movie:
    container_name: movie-container
    build: ./movie-tickets
    ports:
      - "8081:80"
    volumes:
      - movie_volume:/usr/share/nginx/html:ro
    networks:
      - movie_network

  bus:
    container_name: bus-container
    build: ./bus-tickets
    ports:
      - "8082:80"
    volumes:
      - bus_volume:/usr/share/nginx/html:ro
    networks:
      - bus_network

  train:
    container_name: train-container
    build: ./train-tickets
    ports:
      - "8083:80"
    volumes:
      - train_volume:/usr/share/nginx/html:ro
    networks:
      - train_network

volumes:
  movie_volume:
  bus_volume:
  train_volume:

networks:
  movie_network:
  bus_network:
  train_network:
```

---

### Verify Networks

```bash
docker network ls
docker network inspect movie_network
```

âœ” Each service is isolated

---

## ðŸŒ± Environment Variables in Docker Compose

---

### 1ï¸âƒ£ Using `.env` File (BEST PRACTICE)

`.env`

```env
DB_HOST=mysqldb
DB_PORT=3306
```

Compose:

```yaml
environment:
  - DB_SERVER=${DB_HOST}
  - DATABASE_PORT=${DB_PORT}
```

---

### 2ï¸âƒ£ Directly in Compose File

```yaml
environment:
  - DB_ENDPOINT=https://mysqldb.com
  - DB_USER=root
```

---

### 3ï¸âƒ£ Using Host Environment Variables

```bash
export DB_NAME=mustafa
export DB_PORT=3306
```

Compose:

```yaml
environment:
  - DB_NAME=${DB_NAME}
  - DB_PORT=${DB_PORT}
```

---

### Verify Inside Container

```bash
docker exec -it movie-container bash
printenv
```

---

## ðŸ§  Key DevOps Takeaways

- Docker Compose is **declarative**
- One YAML â†’ multiple services
- Built-in DNS & networking
- Volumes persist data
- Environment variables simplify config
- Ideal for **dev, test, CI environments**

---

## ðŸŽ¯ Interview One-Liners

- Docker Compose manages **multi-container applications**
- Services communicate using **service names**
- Volumes persist data across container restarts
- Networks provide **isolation & security**
- `.env` file separates config from code

---

## ðŸ Conclusion

Docker Compose simplifies:

- Multi-service deployments
- Local development
- Testing environments
- DevOps workflows

Mastering Docker Compose prepares you for:

- Real-world microservices
- Kubernetes concepts
- CI/CD pipelines

---

Below are **clean, structured Markdown notes** added for **Scaling in Docker Compose**, written in a **DevOps + interview-ready** format and aligned with your previous Compose notes.

---

# ðŸ“ˆ Scaling in Docker Compose â€“ Hands-On DevOps Notes

## Background

In previous Docker Compose basics, we covered:

- Containers
- Images
- Volumes
- Networks
- Environment variables

This section focuses on **core Compose concepts**:

- Scaling
- Reverse proxy basics
- Real-time application behavior

---

## ðŸš€ Introduction to Scaling in Docker Compose

Docker Compose allows you to **run multiple instances of a service** (containers) using a single Compose file.

Scaling helps:

- Handle increased traffic
- Improve availability
- Optimize resource usage

> âš ï¸ Docker Compose supports **manual scaling only** (not auto-scaling).

---

## ðŸ›’ Real-Time Example: E-Commerce Application

### Scenario

You manage an **E-Commerce web application**:

- Books
- Clothes
- Gadgets

Initially:

- Running on **2â€“10 containers**
- Traffic increases suddenly

### Problem

- Containers get overloaded
- App may crash under high traffic

### Solution: Scaling

#### Scale-Up (Scale-In as per blog wording)

- Increase container count
- Handle more requests

#### Scale-Down (Scale-Out as per blog wording)

- Reduce containers
- Save resources when traffic drops

---

## âš ï¸ Important Rules for Scaling in Docker Compose

### âŒ Do NOT use:

- `container_name`
- Fixed `host_port`

### Why?

| Issue                   | Reason                                            |
| ----------------------- | ------------------------------------------------- |
| Container name conflict | Multiple replicas cannot share the same name      |
| Port conflict           | Multiple containers cannot bind to same host port |

âœ” Docker Compose **auto-generates names & ports** for scaled containers

---

## ðŸ§¾ Compose File for Scaling (Single Service)

```yaml
version: "3"
services:
  movie:
    build: ./train
    ports:
      - "80"
```

### Key Points

- Only **container port** is defined
- No `container_name`
- No host port
- Docker assigns random host ports automatically

---

## â–¶ï¸ Start the Application

```bash
docker-compose up -d
```

---

## ðŸ” Check Running Containers

```bash
docker-compose ps
```

Youâ€™ll see:

- Auto-generated container names
- Random host ports mapped to container port 80

---

## ðŸ“ˆ Scale-Up Containers (Increase Replicas)

### Syntax

```bash
docker-compose up -d --scale service-name=count
```

### Example: Scale to 4 containers

```bash
docker-compose up -d --scale movie=4
```

### Result

- Existing 2 containers
- 2 new containers created
- Total = 4 containers

Verify:

```bash
docker-compose ps
```

---

## ðŸ“‰ Scale-Down Containers (Reduce Replicas)

### Example: Scale down to 1

```bash
docker-compose up -d --scale movie=1
```

### Result

- Extra containers removed
- Only 1 container running

Verify:

```bash
docker ps
```

---

## âš–ï¸ Scaling Benefits

### âœ… Load Balancing

- Traffic distributed across containers
- Docker uses round-robin internally

### âœ… High Availability

- One container failure doesnâ€™t stop the app
- Other replicas continue serving traffic

### âœ… Efficiency

- Scale without changing application code
- Simple command-based scaling

---

## âŒ Drawbacks of Docker Compose Scaling

| Limitation             | Explanation                       |
| ---------------------- | --------------------------------- |
| No auto-scaling        | Scaling is manual                 |
| Single-host only       | Not cluster-aware                 |
| Limited production use | Not ideal for large-scale systems |

> ðŸ‘‰ For **auto-scaling**, move to **Kubernetes (HPA)**

---

## ðŸ§  Interview One-Liners

- Docker Compose supports **manual scaling**
- Do not use `container_name` while scaling
- Do not bind fixed host ports
- Scaling works best with a **reverse proxy**
- Kubernetes is needed for **auto-scaling**

---

## ðŸ Conclusion

Docker Compose scaling:

- Is fast and simple
- Works well for dev & test environments
- Helps simulate real-world load scenarios
- Prepares you for Kubernetes concepts

> **Compose is a stepping stone, Kubernetes is the destination.**

---
